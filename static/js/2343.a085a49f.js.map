{"version":3,"file":"static/js/2343.a085a49f.js","mappings":"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","sources":["../node_modules/@antv/g2/src/geometry/base.ts"],"sourcesContent":["import { Adjust, getAdjust as getAdjustClass } from '@antv/adjust';\nimport { Attribute, getAttribute as getAttributeClass } from '@antv/attr';\nimport {\n  clone,\n  deepMix,\n  each,\n  flatten,\n  get,\n  isArray,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isNil,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  set,\n} from '@antv/util';\nimport { doGroupAppearAnimate, getDefaultAnimateCfg } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GEOMETRY_LIFE_CIRCLE, GROUP_ATTRS } from '../constant';\nimport { BBox, Coordinate, IGroup, IShape, Scale } from '../dependents';\nimport {\n  AdjustOption,\n  AdjustType,\n  AnimateOption,\n  AttributeOption,\n  ColorAttrCallback,\n  Data,\n  Datum,\n  GeometryLabelCfg,\n  GeometryTooltipOption,\n  LabelCallback,\n  LabelOption,\n  LooseObject,\n  MappingDatum,\n  ScaleOption,\n  ShapeAttrCallback,\n  ShapeFactory,\n  ShapeInfo,\n  ShapeMarkerCfg,\n  ShapeMarkerAttrs,\n  ShapePoint,\n  SizeAttrCallback,\n  StateOption,\n  StyleCallback,\n  StyleOption,\n  TooltipCallback,\n  CustomOption,\n} from '../interface';\nimport { uniq } from '../util/helper';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport GeometryLabel from './label/base';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields';\nimport { diff } from './util/diff';\nimport { inferScaleType } from '../util/scale';\nimport { getXDimensionLength } from '../util/coordinate';\n\n/** @ignore */\ninterface AttributeInstanceCfg {\n  fields?: string[];\n  callback?: (...args) => any;\n  values?: string[] | number[];\n  scales?: Scale[];\n}\ninterface DimValuesMapType {\n  [dim: string]: number[];\n}\n/** @ignore */\ninterface AdjustInstanceCfg {\n  type: AdjustType;\n  adjustNames?: string[];\n  xField?: string;\n  yField?: string;\n\n  dodgeBy?: string;\n  marginRatio?: number;\n  dodgeRatio?: number;\n\n  size?: number;\n  height?: number;\n  reverseOrder?: boolean;\n\n  /** 像素级柱间宽度，调整offset */\n  intervalPadding?: number;\n  dodgePadding?: number;\n  /** x维度长度，计算归一化padding使用 */\n  xDimensionLength?: number;\n  /** 分组数，计算offset */\n  groupNum?: number;\n  /** 用户配置宽度 size */\n  defaultSize?: number;\n  /** 最大最小宽度约束 */\n  maxColumnWidth?: number;\n  minColumnWidth?: number;\n  /** 柱宽比例 */\n  columnWidthRatio?: number;\n  /** 用户自定义的dimValuesMap */\n  dimValuesMap?: DimValuesMapType;\n}\n\n/** geometry.init() 传入参数 */\nexport interface InitCfg {\n  /** 坐标系 */\n  coordinate?: Coordinate;\n  /** 数据 */\n  data?: Data;\n  /** 主题对象 */\n  theme?: LooseObject;\n  /** 列定义 */\n  scaleDefs?: Record<string, ScaleOption>;\n  /** 因为数据使用的引用，所以需要有一个标识位标识数据是否发生了更新 */\n  isDataChanged?: boolean;\n  isCoordinateChanged?: boolean;\n}\n\n/** Geometry 构造函数参数 */\nexport interface GeometryCfg {\n  /** Geometry shape 的容器。 */\n  container: IGroup;\n  /** 绘制的坐标系对象。 */\n  coordinate?: Coordinate;\n  /** 绘制数据。 */\n  data?: Data;\n  /** 需要的 scales。 */\n  scales?: Record<string, Scale>;\n  /** 列定义 */\n  scaleDefs?: Record<string, ScaleOption>;\n  /** Geometry labels 的容器 */\n  labelsContainer?: IGroup;\n  /** 是否对数据进行排序 */\n  sortable?: boolean;\n  /** elements 的 zIndex 默认按顺序提升，通过 zIndexReversed 可以反序，从而数据越前，层级越高 */\n  zIndexReversed?: boolean;\n  /** 是否需要对 zIndex 进行 sort。因为耗时长，由具体场景自行决定 */\n  sortZIndex?: boolean;\n  /** 延迟渲染 Geometry 数据标签. 设置为 true 时，会在浏览器空闲时期被调用, 也可以指定具体 timeout 时间 */\n  useDeferredLabel?: boolean | number;\n  /** 是否可见 */\n  visible?: boolean;\n  /** 主题配置 */\n  theme?: LooseObject;\n\n  /** 组间距 */\n  intervalPadding?: number;\n  /** 组内间距 */\n  dodgePadding?: number;\n  /** 柱状图最大宽度 */\n  maxColumnWidth?: number;\n  /** 柱状图最小宽度 */\n  minColumnWidth?: number;\n  /** 默认宽度占比，interval类型和schema类型通用 */\n  columnWidthRatio?: number;\n  /** 玫瑰图占比 */\n  roseWidthRatio?: number;\n  /** 多层饼图/环图占比 */\n  multiplePieWidthRatio?: number;\n}\n\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\nexport default class Geometry<S extends ShapePoint = ShapePoint> extends Base {\n  /** Geometry 几何标记类型。 */\n  public readonly type: string = 'base';\n  /** ShapeFactory 对应的类型。 */\n  public readonly shapeType: string;\n\n  // 在创建 Geometry 实例时可以传入的属性\n  /** Coordinate 坐标系实例。 */\n  public coordinate: Coordinate;\n  /** 用户绘制数据。 */\n  public data: Data;\n  /** 图形绘制容器。 */\n  public readonly container: IGroup;\n  /** label 绘制容器。 */\n  public readonly labelsContainer: IGroup;\n  /** 是否对数据进行排序，默认为 false。  */\n  public sortable: boolean;\n  /** 当前 Geometry 实例主题。  */\n  public theme: LooseObject;\n  /** 存储 geometry 需要的 scales，需要外部传入。 */\n  public scales: Record<string, Scale>;\n  /** scale 定义，需要外部传入。 */\n  public scaleDefs: Record<string, ScaleOption>;\n  /** 画布区域，用于 label 布局。 */\n  public canvasRegion: BBox;\n\n  // 内部产生的属性\n  /** Attribute map  */\n  public attributes: Record<string, Attribute> = {};\n  /** Element map */\n  public elements: Element[] = [];\n  /**\n   * 存储处理后的数据，\n   * + init() 及 updateData() 逻辑后, 结构为 Data[]；\n   * + paint() 逻辑后，结构为 MappingDatum[][]。\n   */\n  public dataArray: MappingDatum[][];\n  /** 存储 tooltip 配置信息。 */\n  public tooltipOption: GeometryTooltipOption | boolean;\n  /** 存储 label 配置信息。 */\n  public labelOption: LabelOption | false;\n  /** 状态量相关的配置项 */\n  public stateOption: StateOption;\n  /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n  public elementsMap: Record<string, Element> = {};\n  /** animate 配置项 */\n  public animateOption: AnimateOption | boolean = true;\n  /** 图形属性映射配置 */\n  protected attributeOption: Record<string, AttributeOption> = {};\n  /** adjust 配置项 */\n  protected adjustOption: AdjustOption[];\n  /** style 配置项 */\n  protected styleOption: StyleOption;\n  /** custom 自定义的配置项 */\n  protected customOption: CustomOption;\n  /** 每个 Geometry 对应的 Shape 工厂实例，用于创建各个 Shape */\n  protected shapeFactory: ShapeFactory;\n  /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n  protected lastElementsMap: Record<string, Element> = {};\n  /** 是否生成多个点来绘制图形。 */\n  protected generatePoints: boolean = false;\n  /** 存储发生图形属性映射前的数据 */\n  protected beforeMappingData: Data[] = null;\n  /** 存储每个 shape 的默认 size，用于 Interval、Schema 几何标记 */\n  protected defaultSize: number;\n\n  // 用户通过 geometry 构造函数设置的主题\n  private userTheme: LooseObject;\n  private adjusts: Record<string, Adjust> = {};\n  private lastAttributeOption;\n  private idFields: string[] = [];\n  private geometryLabel: GeometryLabel;\n\n  // 柱状图间距相关配置\n  /** 组间距 */\n  protected intervalPadding: number;\n  /** 组内间距 */\n  protected dodgePadding: number;\n  /** 柱状图最大宽度 */\n  protected maxColumnWidth: number;\n  /** 柱状图最小宽度 */\n  protected minColumnWidth: number;\n  /** 一般柱状图宽度占比 */\n  protected columnWidthRatio: number;\n  /** 玫瑰图占比 */\n  protected roseWidthRatio: number;\n  /** 多层饼图/环图占比 */\n  protected multiplePieWidthRatio: number;\n  /** elements 的 zIndex 默认按顺序提升，通过 zIndexReversed 可以反序，从而数据越前，层级越高 */\n  public zIndexReversed?: boolean;\n  /** 是否需要对 zIndex 进行 sort。因为耗时长，由具体场景自行决定 */\n  public sortZIndex?: boolean;\n  protected useDeferredLabel?: null | number;\n\n  /** 虚拟 Group，用于图形更新 */\n  private offscreenGroup: IGroup;\n  private groupScales: Scale[];\n  private hasSorted: boolean = false;\n  protected isCoordinateChanged: boolean = false;\n\n  /**\n   * 创建 Geometry 实例。\n   * @param cfg\n   */\n  constructor(cfg: GeometryCfg) {\n    super(cfg);\n\n    const {\n      container,\n      labelsContainer,\n      coordinate,\n      data,\n      sortable = false,\n      visible = true,\n      theme,\n      scales = {},\n      scaleDefs = {},\n      // 柱状图间隔与宽度相关配置\n      intervalPadding,\n      dodgePadding,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n      roseWidthRatio,\n      multiplePieWidthRatio,\n      zIndexReversed,\n      sortZIndex,\n      useDeferredLabel,\n    } = cfg;\n\n    this.container = container;\n    this.labelsContainer = labelsContainer;\n    this.coordinate = coordinate;\n    this.data = data;\n    this.sortable = sortable;\n    this.visible = visible;\n    this.userTheme = theme;\n    this.scales = scales;\n    this.scaleDefs = scaleDefs;\n    // 柱状图间隔与宽度相关配置\n    this.intervalPadding = intervalPadding;\n    this.dodgePadding = dodgePadding;\n    this.maxColumnWidth = maxColumnWidth;\n    this.minColumnWidth = minColumnWidth;\n    this.columnWidthRatio = columnWidthRatio;\n    this.roseWidthRatio = roseWidthRatio;\n    this.multiplePieWidthRatio = multiplePieWidthRatio;\n    this.zIndexReversed = zIndexReversed;\n    this.sortZIndex = sortZIndex;\n    this.useDeferredLabel = useDeferredLabel ? (typeof useDeferredLabel === 'number' ? useDeferredLabel : Infinity) : null;\n  }\n\n  /**\n   * 配置 position 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n   * geometry.position('x*y');\n   * geometry.position([ 'x', 'y' ]);\n   * geometry.position({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   *\n   * @param cfg 映射规则\n   * @returns\n   */\n  public position(cfg: string | string[] | AttributeOption): Geometry {\n    let positionCfg = cfg;\n    if (!isPlainObject(cfg)) {\n      // 字符串字段或者数组字段\n      positionCfg = {\n        fields: parseFields(cfg),\n      };\n    }\n\n    const fields = get(positionCfg, 'fields');\n    if (fields.length === 1) {\n      // 默认填充一维 1*xx\n      fields.unshift('1');\n      set(positionCfg, 'fields', fields);\n    }\n    set(this.attributeOption, 'position', positionCfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 color 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.color({\n   *   fields: [ 'x' ],\n   *   values: [ '#1890ff', '#5AD8A6' ],\n   * });\n   * ```\n   *\n   * @param field 映射规则\n   * @returns\n   */\n  public color(field: AttributeOption): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 使用 '#1890ff' 颜色渲染图形\n   * geometry.color('#1890ff');\n   *\n   * // 根据 x 字段的数据值进行颜色的映射，这时候 G2 会在内部调用默认的回调函数，读取默认提供的颜色进行数据值到颜色值的映射。\n   * geometry.color('x');\n   *\n   * // 将 'x' 字段的数据值映射至指定的颜色值 colors（可以是字符串也可以是数组），此时用于通常映射分类数据\n   * geometry.color('x', [ '#1890ff', '#5AD8A6' ]);\n   *\n   * // 使用回调函数进行颜色值的自定义；可以使用多个字段使用、*号连接\n   * geometry.color('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 'red';\n   *   }\n   *   return 'blue';\n   * });\n   *\n   * // 指定颜色的渐变路径，用于映射连续的数据\n   * geometry.color('x', '#BAE7FF-#1890FF-#0050B3');\n   * ```\n   *\n   * @param field 参与颜色映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, color 映射规则。\n   * @returns\n   */\n  public color(field: string, cfg?: string | string[] | ColorAttrCallback): Geometry;\n  public color(field: AttributeOption | string, cfg?: string | string[] | ColorAttrCallback): Geometry {\n    this.createAttrOption('color', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 shape 通道映射规则。\n   *\n   * @example\n   *\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.shape({\n   *   fields: [ 'x' ],\n   * });\n   * ```\n   *\n   * @param field 映射规则配置。\n   * @returns\n   */\n  public shape(field: AttributeOption): Geometry;\n  /**\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 指定常量，将所有数据值映射到固定的 shape\n   * geometry.shape('circle');\n   *\n   * // 将指定的字段映射到内置的 shapes 数组中\n   * geometry.shape('x');\n   *\n   * // 将指定的字段映射到指定的 shapes 数组中\n   * geometry.shape('x', [ 'circle', 'diamond', 'square' ]);\n   *\n   * // 使用回调函数获取 shape，用于个性化的 shape 定制，可以根据单个或者多个字段确定\n   * geometry.shape('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 'circle';\n   *   }\n   *   return 'diamond';\n   * });\n   * ```\n   *\n   * @param field 参与 shape 映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, shape 映射规则。\n   * @returns\n   */\n  public shape(field: string, cfg?: string[] | ShapeAttrCallback): Geometry;\n  public shape(field: AttributeOption | string, cfg?: string[] | ShapeAttrCallback): Geometry {\n    this.createAttrOption('shape', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 size 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.size({\n   *   values: [ 10 ],\n   * })\n   * ```\n   *\n   * @param field 映射规则。\n   * @returns\n   */\n  public size(field: AttributeOption): Geometry;\n  /**\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 直接指定像素大小\n   * geometry.size(10);\n   *\n   * // 指定映射到 size 的字段，使用内置的默认大小范围为 [1, 10]\n   * geometry.size('x');\n   *\n   * // 指定映射到 size 字段外，还提供了 size 的最大值和最小值范围\n   * geometry.size('x', [ 5, 30 ]);\n   *\n   * // 使用回调函数映射 size，用于个性化的 size 定制，可以使用多个字段进行映射\n   * geometry.size('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 10;\n   *   }\n   *   return 5;\n   * });\n   * ```\n   *\n   * @param field 参与 size 映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, size 映射规则\n   * @returns\n   */\n  public size(field: number | string, cfg?: [number, number] | SizeAttrCallback): Geometry;\n  public size(field: AttributeOption | number | string, cfg?: [number, number] | SizeAttrCallback): Geometry {\n    this.createAttrOption('size', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 设置数据调整方式。G2 目前内置了四种类型：\n   * 1. dodge\n   * 2. stack\n   * 3. symmetric\n   * 4. jitter\n   *\n   *\n   * **Tip**\n   * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('dodge', {\n   *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n   *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n   * });\n   * ```\n   *\n   * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('stack', {\n   *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * geometry.adjust('stack');\n   *\n   * geometry.adjust({\n   *   type: 'stack',\n   *   reverseOrder: false,\n   * });\n   *\n   * // 组合使用 adjust\n   * geometry.adjust([ 'stack', 'dodge' ]);\n   *\n   * geometry.adjust([\n   *   { type: 'stack' },\n   *   { type: 'dodge', dodgeBy: 'x' },\n   * ]);\n   * ```\n   *\n   * @param adjustCfg 数据调整配置\n   * @returns\n   */\n  public adjust(adjustCfg: string | string[] | AdjustOption | AdjustOption[]): Geometry {\n    let adjusts: any = adjustCfg;\n    if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n      adjusts = [adjustCfg];\n    }\n    each(adjusts, (adjust, index) => {\n      if (!isObject(adjust)) {\n        adjusts[index] = { type: adjust };\n      }\n    });\n\n    this.adjustOption = adjusts;\n    return this;\n  }\n\n  /**\n   * 图形样式配置。\n   *\n   * @example\n   * ```typescript\n   * // 配置图形样式\n   * style({\n   *   lineWidth: 2,\n   *   stroke: '#1890ff',\n   * });\n   *\n   * // 根据具体的数据进行详细配置\n   * style({\n   *   fields: [ 'x', 'y' ], // 数据字段\n   *   callback: (xVal, yVal) => {\n   *     const style = { lineWidth: 2, stroke: '#1890ff' };\n   *     if (xVal === 'a') {\n   *       style.lineDash = [ 2, 2 ];\n   *     }\n   *     return style;\n   *   },\n   * });\n   * ```\n   *\n   * @param field 配置样式属性或者样式规则。\n   * @returns\n   */\n  public style(field: StyleOption | LooseObject): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * style('x*y', (xVal, yVal) => {\n   *   const style = { lineWidth: 2, stroke: '#1890ff' };\n   *   if (xVal === 'a') {\n   *     style.lineDash = [ 2, 2 ];\n   *   }\n   *   return style;\n   * });\n   * ```\n   *\n   * @param field 数据字段或者样式配置规则。\n   * @param styleFunc Optional, 样式配置回调函数。\n   * @returns\n   */\n  public style(field: string, styleFunc: StyleCallback): Geometry;\n  public style(field: StyleOption | LooseObject | string, styleFunc?: StyleCallback): Geometry {\n    if (isString(field)) {\n      const fields = parseFields(field);\n      this.styleOption = {\n        fields,\n        callback: styleFunc,\n      };\n    } else {\n      const { fields, callback, cfg } = field as StyleOption;\n      if (fields || callback || cfg) {\n        this.styleOption = field;\n      } else {\n        this.styleOption = {\n          cfg: field,\n        };\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 配置 Geometry 显示的 tooltip 内容。\n   *\n   * `tooltip(false)` 代表关闭 tooltip。\n   * `tooltip(true)` 代表开启 tooltip。\n   *\n   * Geometry 默认允许 tooltip 展示，我们可以使用以下方法对 tooltip 的展示内容进行配置：\n   *\n   * @example\n   * ```typescript\n   * // data: [{x: 'a', y: 10}]\n   * tooltip({\n   *   fields: [ 'x' ],\n   * });\n   * ```\n   * ![](https://gw.alipayobjects.com/mdn/rms_2274c3/afts/img/A*268uQ50if60AAAAAAAAAAABkARQnAQ)\n   *\n   * ```typescript\n   * tooltip({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   * ![](https://gw.alipayobjects.com/mdn/rms_2274c3/afts/img/A*A_ujSa8QhtcAAAAAAAAAAABkARQnAQ)\n   *\n   * tooltip() 方法同样支持数据映射及回调用法：\n   *\n   * @example\n   * ```typescript\n   * chart.tooltip({\n   *   itemTpl: '<li>{x}: {y}</li>',\n   * });\n   *\n   * chart.line()\n   *   .position('x*y')\n   *   .tooltip({\n   *     fields: [ 'x', 'y' ],\n   *     callback: (x, y) => {\n   *       return {\n   *         x,\n   *         y,\n   *       };\n   *     },\n   *   });\n   * ```\n   *\n   * 其返回的值必须为对象，该值中的属性同 chart.tooltip() 的 itemTpl 模板相对应，返回的变量可用于 itemTpl 的字符串模板。\n   *\n   * @param field tooltip 配置信息。\n   * @returns\n   */\n  public tooltip(field: GeometryTooltipOption | boolean): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * // data: [{x: 'a', y: 10}]\n   *\n   * // 等同于 tooltip({ fields: [ 'x' ] })\n   * tooltip('x');\n   *\n   * // 等同于 tooltip({ fields: [ 'x', 'y' ] })\n   * tooltip('x*y');\n   *\n   * // 等同于 tooltip({ fields: [ 'x', 'y' ], callback: (x, y) => { x, y } })\n   * tooltip('x*y', (x, y) => {\n   *   return {\n   *     x,\n   *     y,\n   *   };\n   * });\n   * ```\n   *\n   * @param field 参与映射的字段。\n   * @param cfg Optional, 回调函数\n   * @returns\n   */\n  public tooltip(field: string, cfg?: TooltipCallback): Geometry;\n  public tooltip(field: GeometryTooltipOption | boolean | string, cfg?: TooltipCallback): Geometry {\n    if (isString(field)) {\n      const fields = parseFields(field);\n      this.tooltipOption = {\n        fields,\n        callback: cfg,\n      };\n    } else {\n      this.tooltipOption = field;\n    }\n\n    return this;\n  }\n\n  /**\n   * Geometry 动画配置。\n   *\n   * + `animate(false)` 关闭动画\n   * + `animate(true)` 开启动画，默认开启。\n   *\n   * 我们将动画分为四个场景：\n   * 1. appear: 图表第一次加载时的入场动画；\n   * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n   * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n   * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n   *\n   * @example\n   * ```typescript\n   * animate({\n   *   enter: {\n   *     duration: 1000, // enter 动画执行时间\n   *   },\n   *   leave: false, // 关闭 leave 销毁动画\n   * });\n   * ```\n   *\n   * @param cfg 动画配置\n   * @returns\n   */\n  public animate(cfg: AnimateOption | boolean): Geometry {\n    this.animateOption = cfg;\n    return this;\n  }\n\n  /**\n   * Geometry label 配置。\n   *\n   * @example\n   * ```ts\n   * // data: [ {x: 1, y: 2, z: 'a'}, {x: 2, y: 2, z: 'b'} ]\n   * // 在每个图形上显示 z 字段对应的数值\n   * label({\n   *   fields: [ 'z' ]\n   * });\n   *\n   * label(false); // 不展示 label\n   *\n   * // 在每个图形上显示 x 字段对应的数值，同时配置文本颜色为红色\n   * label('x', {\n   *   style: {\n   *     fill: 'red',\n   *   },\n   * })\n   *\n   * // 以 type 类型的 label 渲染每个图形上显示 x 字段对应的数值，同时格式化文本内容\n   * label('x', (xValue) => {\n   *   return {\n   *     content: xValue + '%',\n   *   };\n   * }, {\n   *   type: 'base' // 声明 label 类型\n   * })\n   * ```\n   *\n   * @param field\n   * @returns label\n   */\n  public label(field: LabelOption | false | string): Geometry;\n  public label(field: string, secondParam: GeometryLabelCfg | LabelCallback): Geometry;\n  public label(field: string, secondParam: LabelCallback, thirdParam: GeometryLabelCfg): Geometry;\n  public label(\n    field: string | LabelOption | false,\n    secondParam?: GeometryLabelCfg | LabelCallback,\n    thirdParam?: GeometryLabelCfg\n  ): Geometry {\n    if (isString(field)) {\n      const labelOption: LabelOption = {};\n      const fields = parseFields(field);\n      labelOption.fields = fields;\n      if (isFunction(secondParam)) {\n        labelOption.callback = secondParam;\n      } else if (isPlainObject(secondParam)) {\n        labelOption.cfg = secondParam;\n      }\n\n      if (thirdParam) {\n        labelOption.cfg = thirdParam;\n      }\n      this.labelOption = labelOption;\n    } else {\n      this.labelOption = field;\n    }\n\n    return this;\n  }\n\n  /**\n   * 设置状态对应的样式。\n   *\n   * @example\n   * ```ts\n   * chart.interval().state({\n   *   selected: {\n   *     animate: { duration: 100, easing: 'easeLinear' },\n   *     style: {\n   *       lineWidth: 2,\n   *       stroke: '#000',\n   *     },\n   *   },\n   * });\n   * ```\n   *\n   * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n   * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n   *\n   * ```ts\n   * chart.interval().shape('groupShape').state({\n   *   selected: {\n   *     style: {\n   *       0: { lineWidth: 2 },\n   *       1: { fillOpacity: 1 },\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg 状态样式\n   */\n  public state(cfg: StateOption) {\n    this.stateOption = cfg;\n    return this;\n  }\n\n  /**\n   * 用于向 shape 中传入自定义的数据。目前可能仅仅可能用于在自定义 shape 的时候，像自定义 shape 中传入自定义的数据，方便实现自定义 shape 的配置能力。\n   *\n   * @example\n   * ```ts\n   * chart.interval().customInfo({ yourData: 'hello, g2!' });\n   * ```\n   *\n   * 然后在自定义 shape 的时候，可以拿到这个信息。\n   *\n   * ```ts\n   * registerShape('interval', 'your-shape', {\n   *   draw(shapeInfo, container) {\n   *     const { customInfo } = shapeInfo;\n   *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg\n   */\n  public customInfo(cfg: any) {\n    this.customOption = cfg;\n    return this;\n  }\n\n  /**\n   * 初始化 Geomtry 实例：\n   * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n   */\n  public init(cfg: InitCfg = {}) {\n    this.setCfg(cfg);\n    this.initAttributes(); // 创建图形属性\n\n    // 数据加工：分组 -> 数字化 -> adjust\n    this.processData(this.data);\n\n    // 调整 scale\n    this.adjustScale();\n  }\n\n  /**\n   * Geometry 更新。\n   * @param [cfg] 更新的配置\n   */\n  public update(cfg: InitCfg = {}) {\n    const { data, isDataChanged, isCoordinateChanged } = cfg;\n    const { attributeOption, lastAttributeOption } = this;\n\n    if (!isEqual(attributeOption, lastAttributeOption)) {\n      // 映射发生改变，则重新创建图形属性\n      this.init(cfg);\n    } else if (data && (isDataChanged || !isEqual(data, this.data))) {\n      // 数据发生变化\n      this.setCfg(cfg);\n      this.initAttributes(); // 创建图形属性\n      this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n    } else {\n      // 有可能 coordinate 变化\n      this.setCfg(cfg);\n    }\n\n    // 调整 scale\n    this.adjustScale();\n    this.isCoordinateChanged = isCoordinateChanged;\n  }\n\n  /**\n   * 将原始数据映射至图形空间，同时创建图形对象。\n   */\n  public paint(isUpdate: boolean = false) {\n    if (this.animateOption) {\n      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);\n    }\n\n    this.defaultSize = undefined;\n    this.elementsMap = {};\n    this.elements = [];\n    const offscreenGroup = this.getOffscreenGroup();\n    offscreenGroup.clear();\n\n    const beforeMappingData = this.beforeMappingData;\n    const dataArray = this.beforeMapping(beforeMappingData);\n\n    this.dataArray = new Array(dataArray.length);\n    for (let i = 0; i < dataArray.length; i++) {\n      const data = dataArray[i];\n      this.dataArray[i] = this.mapping(data);\n    }\n    this.updateElements(this.dataArray, isUpdate);\n    this.lastElementsMap = this.elementsMap;\n\n    if (this.canDoGroupAnimation(isUpdate)) {\n      // 如果用户没有配置 appear.animation，就默认走整体动画\n      const container = this.container;\n      const type = this.type;\n      const coordinate = this.coordinate;\n      const animateCfg = get(this.animateOption, 'appear');\n      const yScale = this.getYScale();\n      const yMinPoint = coordinate.convert({\n        x: 0,\n        y: yScale.scale(this.getYMinValue()),\n      });\n      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n    }\n\n    // 添加 label\n    if (this.labelOption) {\n      const deferred = this.useDeferredLabel;\n      const callback = (() => this.renderLabels(flatten(this.dataArray) as unknown as MappingDatum[], isUpdate)).bind(this);\n      if (typeof deferred === 'number') {\n        // Use `requestIdleCallback` to render labels in idle time (like react fiber)\n        const timeout = (typeof deferred === 'number' && deferred !== Infinity) ? deferred : 0;\n        if (!window.requestIdleCallback) {\n          setTimeout(callback, timeout);\n        } else {\n          const options = timeout && timeout !== Infinity ? { timeout } : undefined;\n          window.requestIdleCallback(callback, options);\n        }\n      } else {\n        callback();\n      }\n    }\n\n    // 缓存，用于更新\n    this.lastAttributeOption = {\n      ...this.attributeOption,\n    };\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  }\n\n  /**\n   * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n   * @override\n   */\n  public clear() {\n    const { container, geometryLabel, offscreenGroup } = this;\n    if (container) {\n      container.clear();\n    }\n\n    if (geometryLabel) {\n      geometryLabel.clear();\n    }\n\n    if (offscreenGroup) {\n      offscreenGroup.clear();\n    }\n\n    // 属性恢复至出厂状态\n    this.scaleDefs = undefined;\n    this.attributes = {};\n    this.scales = {};\n    this.elementsMap = {};\n    this.lastElementsMap = {};\n    this.elements = [];\n    this.adjusts = {};\n    this.dataArray = null;\n    this.beforeMappingData = null;\n    this.lastAttributeOption = undefined;\n    this.defaultSize = undefined;\n    this.idFields = [];\n    this.groupScales = undefined;\n    this.hasSorted = false;\n    this.isCoordinateChanged = false;\n  }\n\n  /**\n   * 销毁 Geometry 实例。\n   */\n  public destroy() {\n    this.clear();\n    const container = this.container;\n    container.remove(true);\n\n    if (this.offscreenGroup) {\n      this.offscreenGroup.remove(true);\n      this.offscreenGroup = null;\n    }\n\n    if (this.geometryLabel) {\n      this.geometryLabel.destroy();\n      this.geometryLabel = null;\n    }\n    this.theme = undefined;\n    this.shapeFactory = undefined;\n\n    super.destroy();\n  }\n\n  /**\n   * 获取决定分组的图形属性对应的 scale 实例。\n   * @returns\n   */\n  public getGroupScales(): Scale[] {\n    return this.groupScales;\n  }\n\n  /**\n   * 根据名字获取图形属性实例。\n   */\n  public getAttribute(name: string): Attribute {\n    return this.attributes[name];\n  }\n\n  /** 获取 x 轴对应的 scale 实例。 */\n  public getXScale(): Scale {\n    return this.getAttribute('position').scales[0];\n  }\n\n  /** 获取 y 轴对应的 scale 实例。 */\n  public getYScale(): Scale {\n    return this.getAttribute('position').scales[1];\n  }\n\n  /**\n   * 获取决定分组的图形属性实例。\n   */\n  public getGroupAttributes(): Attribute[] {\n    const rst = [];\n    each(this.attributes, (attr: Attribute) => {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  }\n\n  /** 获取图形属性默认的映射值。 */\n  public getDefaultValue(attrName: string) {\n    let value: any;\n    const attr = this.getAttribute(attrName);\n    if (attr && isEmpty(attr.scales)) {\n      // 获取映射至常量的值\n      value = attr.values[0];\n    }\n    return value;\n  }\n\n  /**\n   * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n   * @param attr Attribute 图形属性实例。\n   * @param obj 需要进行映射的原始数据。\n   * @returns\n   */\n  public getAttributeValues(attr: Attribute, obj: Datum) {\n    const params = [];\n    const scales = attr.scales;\n    for (let index = 0, length = scales.length; index < length; index++) {\n      const scale = scales[index];\n      const field = scale.field;\n      if (scale.isIdentity) {\n        params.push(scale.values);\n      } else {\n        params.push(obj[field]);\n      }\n    }\n\n    return attr.mapping(...params);\n  }\n\n  /**\n   * 获取对应的 adjust 实例\n   * @param adjustType\n   * @returns\n   */\n  public getAdjust(adjustType: string) {\n    return this.adjusts[adjustType];\n  }\n\n  /**\n   * 获得 coordinate 实例\n   * @returns\n   */\n  public getCoordinate() {\n    return this.coordinate;\n  }\n\n  public getData() {\n    return this.data;\n  }\n\n  /**\n   * 获取 shape 对应的 marker 样式。\n   * @param shapeName shape 具体名字\n   * @param cfg marker 信息\n   * @returns\n   */\n  public getShapeMarker(shapeName: string, cfg: ShapeMarkerCfg): ShapeMarkerAttrs {\n    const shapeFactory = this.getShapeFactory();\n    return shapeFactory.getMarker(shapeName, cfg);\n  }\n\n  /**\n   * 根据一定的规则查找 Geometry 的 Elements。\n   *\n   * ```typescript\n   * getElementsBy((element) => {\n   *   const data = element.getData();\n   *\n   *   return data.a === 'a';\n   * });\n   * ```\n   *\n   * @param condition 定义查找规则的回调函数。\n   * @returns\n   */\n  public getElementsBy(condition: (element: Element) => boolean): Element[] {\n    return this.elements.filter((element) => condition(element));\n  }\n\n  /**\n   * 获取 Geometry 的所有 Elements。\n   *\n   * ```typescript\n   * getElements();\n   * ```\n   */\n  public getElements() {\n    return this.elements;\n  }\n\n  /**\n   * 获取数据对应的唯一 id。\n   * @param data Element 对应的绘制数据\n   * @returns\n   */\n  public getElementId(data: MappingDatum | MappingDatum[]) {\n    data = isArray(data) ? data[0] : data;\n    const originData = data[FIELD_ORIGIN];\n\n    // 如果用户声明了使用哪些字段作为 id 值\n    if (this.idFields.length) {\n      let elementId = originData[this.idFields[0]];\n      for (let index = 1; index < this.idFields.length; index++) {\n        elementId += '-' + originData[this.idFields[index]];\n      }\n\n      return elementId;\n    }\n\n    const type = this.type;\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n    const xField = xScale.field || 'x';\n    const yField = yScale.field || 'y';\n    const yVal = originData[yField];\n    let xVal;\n    if (xScale.type === 'identity') {\n      xVal = xScale.values[0];\n    } else {\n      xVal = originData[xField];\n    }\n\n    let id: string;\n    if (type === 'interval' || type === 'schema') {\n      id = `${xVal}`;\n    } else if (type === 'line' || type === 'area' || type === 'path') {\n      id = type;\n    } else {\n      id = `${xVal}-${yVal}`;\n    }\n\n    const groupScales = this.groupScales;\n\n    for (let index = 0, length = groupScales.length; index < length; index++) {\n      const groupScale = groupScales[index];\n      const field = groupScale.field;\n      id = `${id}-${originData[field]}`;\n    }\n\n    // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n    const dodgeAdjust = this.getAdjust('dodge');\n    if (dodgeAdjust) {\n      const dodgeBy = dodgeAdjust.dodgeBy;\n      if (dodgeBy) {\n        id = `${id}-${originData[dodgeBy]}`;\n      }\n    }\n\n    if (this.getAdjust('jitter')) {\n      id = `${id}-${data.x}-${data.y}`;\n    }\n\n    return id;\n  }\n\n  /**\n   * 获取所有需要创建 scale 的字段名称。\n   */\n  public getScaleFields(): string[] {\n    const fields = [];\n    const tmpMap = new Map();\n    const { attributeOption, labelOption, tooltipOption } = this;\n    // 获取图形属性上的 fields\n    for (const attributeType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attributeType)) {\n        const eachOpt = attributeOption[attributeType];\n        if (eachOpt.fields) {\n          uniq(eachOpt.fields, fields, tmpMap);\n        } else if (eachOpt.values) {\n          // 考虑 size(10), shape('circle') 等场景\n          uniq(eachOpt.values, fields, tmpMap);\n        }\n      }\n    }\n    // 获取 label 上的字段\n    if (labelOption && labelOption.fields) {\n      uniq(labelOption.fields, fields, tmpMap);\n    }\n\n    // 获取 tooltip 上的字段\n    if (isObject(tooltipOption) && tooltipOption.fields) {\n      uniq(tooltipOption.fields, fields, tmpMap);\n    }\n\n    return fields;\n  }\n\n  /**\n   * 显示或者隐藏 geometry。\n   * @param visible\n   */\n  public changeVisible(visible: boolean) {\n    super.changeVisible(visible);\n    const elements = this.elements;\n    for (let index = 0, length = elements.length; index < length; index++) {\n      const element = elements[index];\n      element.changeVisible(visible);\n    }\n    if (visible) {\n      if (this.container) {\n        this.container.show();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.show();\n      }\n    } else {\n      if (this.container) {\n        this.container.hide();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.hide();\n      }\n    }\n  }\n\n  /**\n   * 获得所有的字段\n   */\n  public getFields() {\n    const uniqMap = new Map<string, boolean>();\n    const fields = [];\n\n    Object.values(this.attributeOption).forEach((cfg) => {\n      const fs = cfg?.fields || [];\n      fs.forEach((f) => {\n        if (!uniqMap.has(f)) {\n          fields.push(f);\n        }\n        uniqMap.set(f, true);\n      });\n    }, []);\n\n    return fields;\n  }\n\n  /**\n   * 获取当前配置中的所有分组 & 分类的字段。\n   * @return fields string[]\n   */\n  public getGroupFields(): string[] {\n    const groupFields = [];\n    const tmpMap = new Map(); // 用于去重过滤\n    for (let index = 0, length = GROUP_ATTRS.length; index < length; index++) {\n      const attributeName = GROUP_ATTRS[index];\n      const cfg = this.attributeOption[attributeName];\n      if (cfg && cfg.fields) {\n        uniq(cfg.fields, groupFields, tmpMap);\n      }\n    }\n\n    return groupFields;\n  }\n\n  /**\n   * 获得图形的 x y 字段。\n   */\n  public getXYFields() {\n    const [x, y] = this.attributeOption.position.fields;\n    return [x, y];\n  }\n\n  /**\n   * x 字段\n   * @returns\n   */\n  public getXField(): string {\n    return get(this.getXYFields(), [0]);\n  }\n\n  /**\n   * y 字段\n   * @returns\n   */\n  public getYField(): string {\n    return get(this.getXYFields(), [1]);\n  }\n\n  /**\n   * 获取该 Geometry 下所有生成的 shapes。\n   * @returns shapes\n   */\n  public getShapes(): (IShape | IGroup)[] {\n    return this.elements.map((element: Element) => element.shape);\n  }\n\n  /**\n   * 获取虚拟 Group。\n   * @returns\n   */\n  public getOffscreenGroup() {\n    if (!this.offscreenGroup) {\n      const GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n    return this.offscreenGroup;\n  }\n\n  // 对数据进行排序\n  public sort(mappingArray: Data[]) {\n    if (!this.hasSorted) {\n      // 未发生过排序\n      const xScale = this.getXScale();\n      const xField = xScale.field;\n      for (let index = 0; index < mappingArray.length; index++) {\n        const itemArr = mappingArray[index];\n        itemArr.sort((obj1: Datum, obj2: Datum) => {\n          return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);\n        });\n      }\n    }\n\n    this.hasSorted = true;\n  }\n\n  /**\n   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n   */\n  protected adjustScale() {\n    const yScale = this.getYScale();\n    // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n    if (yScale && this.getAdjust('stack')) {\n      this.updateStackRange(yScale, this.beforeMappingData);\n    }\n  }\n\n  /**\n   * 获取当前 Geometry 对应的 Shape 工厂实例。\n   */\n  protected getShapeFactory() {\n    const shapeType = this.shapeType;\n    if (!getShapeFactory(shapeType)) {\n      return;\n    }\n    if (!this.shapeFactory) {\n      this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n    }\n    // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n    this.shapeFactory.coordinate = this.coordinate;\n    // theme 原因同上\n    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};\n\n    return this.shapeFactory;\n  }\n\n  /**\n   * 获取每个 Shape 对应的关键点数据。\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n  protected createShapePointsCfg(obj: Datum): S {\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n    const x = this.normalizeValues(obj[xScale.field], xScale);\n    let y; // 存在没有 y 的情况\n\n    if (yScale) {\n      y = this.normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x,\n      y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined,\n    } as S;\n  }\n\n  /**\n   * 创建 Element 实例。\n   * @param mappingDatum Element 对应的绘制数据\n   * @param [isUpdate] 是否处于更新阶段\n   * @returns element 返回创建的 Element 实例\n   */\n  protected createElement(mappingDatum: MappingDatum, index: number, isUpdate: boolean = false): Element {\n    const { container } = this;\n\n    const shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n    const shapeFactory = this.getShapeFactory();\n\n    const element = new Element({\n      shapeFactory,\n      container,\n      offscreenGroup: this.getOffscreenGroup(),\n      elementIndex: index,\n    });\n    element.animate = this.animateOption;\n    element.geometry = this;\n    element.draw(shapeCfg, isUpdate); // 绘制\n\n    return element;\n  }\n\n  /**\n   * 获取每条数据对应的图形绘制数据。\n   * @param mappingDatum 映射后的数据\n   * @returns draw cfg\n   */\n  protected getDrawCfg(mappingDatum: MappingDatum): ShapeInfo {\n    const originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n    const cfg: ShapeInfo = {\n      mappingData: mappingDatum, // 映射后的数据\n      data: originData, // 原始数据\n      x: mappingDatum.x,\n      y: mappingDatum.y,\n      color: mappingDatum.color,\n      size: mappingDatum.size,\n      isInCircle: this.coordinate.isPolar,\n      customInfo: this.customOption,\n    };\n\n    let shapeName = mappingDatum.shape;\n    if (!shapeName && this.getShapeFactory()) {\n      shapeName = this.getShapeFactory().defaultShapeType;\n    }\n    cfg.shape = shapeName;\n    // 获取默认样式\n    const theme = this.theme.geometries[this.shapeType];\n    cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n    if (!cfg.defaultStyle && this.getShapeFactory()) {\n      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);\n    }\n\n    const styleOption = this.styleOption;\n    if (styleOption) {\n      cfg.style = this.getStyleCfg(styleOption, originData);\n    }\n    if (this.generatePoints) {\n      cfg.points = mappingDatum.points;\n      cfg.nextPoints = mappingDatum.nextPoints;\n    }\n\n    return cfg;\n  }\n\n  protected updateElements(mappingDataArray: MappingDatum[][], isUpdate: boolean = false): void {\n    const keyDatum = new Map<string, MappingDatum>();\n    const keys: string[] = [];\n\n    // 用来保持 diff 元素之后 added, updated 的相对顺序\n    const keyIndex = new Map<string, number>();\n    let index = 0;\n\n    // 获得更新数据所有的 keys\n    // 将更新的数据用 key 索引\n    for (let i = 0; i < mappingDataArray.length; i++) {\n      const mappingData = mappingDataArray[i];\n      for (let j = 0; j < mappingData.length; j++) {\n        const mappingDatum = mappingData[j];\n        const key = this.getElementId(mappingDatum);\n        const finalKey = keyDatum.has(key) ? `${key}-${i}-${j}` : key;\n        keys.push(finalKey);\n        keyDatum.set(finalKey, mappingDatum);\n        keyIndex.set(finalKey, index);\n        index++;\n      }\n    }\n\n    this.elements = new Array(index);\n\n    const { added, updated, removed } = diff(this.lastElementsMap, keys);\n\n    // 新建 element\n    for (const key of added) {\n      const mappingDatum = keyDatum.get(key);\n      const i = keyIndex.get(key);\n      const element = this.createElement(mappingDatum, i, isUpdate);\n      this.elements[i] = element;\n      this.elementsMap[key] = element;\n      if (element.shape) {\n        element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n      }\n    }\n\n    // 更新 element\n    for (const key of updated) {\n      const element = this.lastElementsMap[key];\n      const mappingDatum = keyDatum.get(key);\n      const currentShapeCfg = this.getDrawCfg(mappingDatum);\n      const preShapeCfg = element.getModel();\n      const i = keyIndex.get(key);\n      if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {\n        element.animate = this.animateOption;\n        // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n        element.update(currentShapeCfg); // 更新对应的 element\n      }\n      this.elements[i] = element;\n      this.elementsMap[key] = element;\n      if (element.shape) {\n        element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n      }\n    }\n\n    // 全部 setZIndex 之后，再执行 sort\n    if (this.container) {\n      this.container.sort();\n    }\n\n    // 销毁被删除的 elements\n    for (const key of removed) {\n      const element = this.lastElementsMap[key];\n      // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n      element.animate = this.animateOption;\n      element.destroy();\n    }\n  }\n\n  /**\n   * 获取渲染的 label 类型。\n   */\n  protected getLabelType(): string {\n    const { labelOption, coordinate, type } = this;\n    const { type: coordinateType, isTransposed } = coordinate;\n    let labelType = get(labelOption, ['cfg', 'type']);\n    if (!labelType) {\n      // 用户未定义，则进行默认的逻辑\n      if (coordinateType === 'polar') {\n        // 极坐标下使用通用的极坐标文本，转置则使用饼图\n        labelType = isTransposed ? 'pie' : 'polar';\n      } else if (coordinateType === 'theta') {\n        // theta 坐标系下使用饼图文本\n        labelType = 'pie';\n      } else if (type === 'interval' || type === 'polygon') {\n        labelType = 'interval';\n      } else {\n        labelType = 'base';\n      }\n    }\n\n    return labelType;\n  }\n\n  /**\n   * 获取 Y 轴上的最小值。\n   */\n  protected getYMinValue(): number {\n    const yScale = this.getYScale();\n    const { min, max } = yScale;\n    let value: number;\n\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n    return value;\n  }\n\n  // 创建图形属性相关的配置项\n  protected createAttrOption(attrName: string, field: AttributeOption | string | number, cfg?) {\n    if (isNil(field) || isObject(field)) {\n      if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n        // shape({ values: [ 'funnel' ] })\n        set(this.attributeOption, attrName, {\n          fields: field.values,\n        });\n      } else {\n        set(this.attributeOption, attrName, field);\n      }\n    } else {\n      const attrCfg: AttributeOption = {};\n      if (isNumber(field)) {\n        // size(3)\n        attrCfg.values = [field];\n      } else {\n        attrCfg.fields = parseFields(field);\n      }\n\n      if (cfg) {\n        if (isFunction(cfg)) {\n          attrCfg.callback = cfg;\n        } else {\n          attrCfg.values = cfg;\n        }\n      }\n\n      set(this.attributeOption, attrName, attrCfg);\n    }\n  }\n\n  protected initAttributes() {\n    const { attributes, attributeOption, theme, shapeType } = this;\n    this.groupScales = [];\n    const tmpMap = {};\n\n    // 遍历每一个 attrOption，各自创建 Attribute 实例\n    for (const attrType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attrType)) {\n        const option: AttributeOption = attributeOption[attrType];\n        if (!option) {\n          return;\n        }\n        const attrCfg: AttributeInstanceCfg = {\n          ...option,\n        };\n        const { callback, values, fields = [] } = attrCfg;\n\n        // 获取每一个字段对应的 scale\n        const scales = fields.map((field) => {\n          const scale = this.scales[field];\n          if (!tmpMap[field] && GROUP_ATTRS.includes(attrType)) {\n            const inferedScaleType = inferScaleType(scale, get(this.scaleDefs, field), attrType, this.type);\n            if (inferedScaleType === 'cat') {\n              this.groupScales.push(scale);\n              tmpMap[field] = true;\n            }\n          }\n          return scale;\n        });\n\n        attrCfg.scales = scales;\n\n        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n          // 用户在图形通道上声明了常量字段 color('red'), size(5)\n          attrCfg.values = scales[0].values;\n        } else if (!callback && !values) {\n          // 用户没有指定任何规则，则使用默认的映射规则\n          if (attrType === 'size') {\n            attrCfg.values = theme.sizes;\n          } else if (attrType === 'shape') {\n            attrCfg.values = theme.shapes[shapeType] || [];\n          } else if (attrType === 'color') {\n            if (scales.length) {\n              // 根据数值个数使用对应的色板\n              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n            } else {\n              attrCfg.values = theme.colors10;\n            }\n          }\n        }\n        const AttributeCtor = getAttributeClass(attrType);\n        attributes[attrType] = new AttributeCtor(attrCfg);\n      }\n    }\n  }\n\n  // 处理数据：分组 -> 数字化 -> adjust 调整\n  private processData(data: Data) {\n    this.hasSorted = false;\n    const { scales } = this.getAttribute('position');\n    const categoryScales = scales.filter((scale: Scale) => scale.isCategory);\n\n    const groupedArray = this.groupData(data); // 数据分组\n    const beforeAdjust = [];\n    for (let i = 0, len = groupedArray.length; i < len; i++) {\n      const subData = groupedArray[i];\n      const arr = [];\n      for (let j = 0, subLen = subData.length; j < subLen; j++) {\n        const originData = subData[j];\n        const item = {};\n        // tslint:disable-next-line: forin\n        for (const k in originData) {\n          item[k] = originData[k];\n        }\n        item[FIELD_ORIGIN] = originData;\n\n        // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n        for (const scale of categoryScales) {\n          const field = scale.field;\n          item[field] = scale.translate(item[field]);\n        }\n        arr.push(item);\n      }\n      beforeAdjust.push(arr);\n    }\n\n    const dataArray = this.adjustData(beforeAdjust); // 进行 adjust 数据调整\n    this.beforeMappingData = dataArray;\n\n    return dataArray;\n  }\n\n  // 调整数据\n  private adjustData(dataArray: Data[]): Data[] {\n    const adjustOption = this.adjustOption;\n    const { intervalPadding, dodgePadding, theme } = this;\n    // 兼容theme配置\n    const maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;\n    const minColumnWidth = this.minColumnWidth || theme.minColumnWidth;\n    const columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;\n    let result = dataArray;\n\n    if (adjustOption) {\n      const xScale = this.getXScale();\n      const yScale = this.getYScale();\n      const xField = xScale.field;\n      const yField = yScale ? yScale.field : null;\n      const xDimensionLength = getXDimensionLength(this.coordinate);\n      const groupNum = xScale.values.length;\n      // 传入size计算相关参数，默认宽度、最大最小宽度约束\n      const sizeAttr = this.getAttribute('size');\n      let defaultSize;\n      if (sizeAttr) {\n        defaultSize = sizeAttr.values[0];\n      }\n      for (let i = 0, len = adjustOption.length; i < len; i++) {\n        const adjust = adjustOption[i];\n        const adjustCfg: AdjustInstanceCfg = {\n          xField,\n          yField,\n          intervalPadding,\n          dodgePadding,\n          xDimensionLength,\n          groupNum,\n          defaultSize,\n          maxColumnWidth,\n          minColumnWidth,\n          columnWidthRatio,\n          ...adjust,\n        };\n        const type = adjust.type;\n        if (type === 'dodge') {\n          const adjustNames = [];\n          if (xScale.isCategory || xScale.type === 'identity') {\n            adjustNames.push('x');\n          } else if (!yScale) {\n            adjustNames.push('y');\n          } else {\n            throw new Error('dodge is not support linear attribute, please use category attribute!');\n          }\n          adjustCfg.adjustNames = adjustNames;\n          // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n          // 兼容theme配置\n          adjustCfg.dodgeRatio = columnWidthRatio;\n        } else if (type === 'stack') {\n          const coordinate = this.coordinate;\n          if (!yScale) {\n            // 一维的情况下获取高度和默认size\n            adjustCfg.height = coordinate.getHeight();\n            const size = this.getDefaultValue('size') || 3;\n            adjustCfg.size = size;\n          }\n          // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n          if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n            adjustCfg.reverseOrder = true;\n          }\n        }\n        const adjustCtor = getAdjustClass(type);\n        adjustCfg.dimValuesMap = {};\n        //生成dimValuesMap\n        if (xScale && xScale.values) {\n          adjustCfg.dimValuesMap[xScale.field] = xScale.values.map((v) => xScale.translate(v));\n        }\n        const adjustInstance = new adjustCtor(adjustCfg);\n\n        result = adjustInstance.process(result);\n\n        this.adjusts[type] = adjustInstance;\n      }\n    }\n\n    return result;\n  }\n\n  // 对数据进行分组\n  private groupData(data: Data): Data[] {\n    const groupScales = this.getGroupScales();\n    const scaleDefs = this.scaleDefs;\n    const appendConditions = {};\n    const groupFields = [];\n    for (let index = 0; index < groupScales.length; index++) {\n      const scale = groupScales[index];\n      const field = scale.field;\n      groupFields.push(field);\n      if (get(scaleDefs, [field, 'values'])) {\n        // 用户通过 view.scale() 接口指定了 values 属性\n        appendConditions[field] = scaleDefs[field].values;\n      }\n    }\n\n    return group(data, groupFields, appendConditions);\n  }\n\n  // 更新发生层叠后的数据对应的度量范围\n  private updateStackRange(scale: Scale, dataArray: Data[]) {\n    const mergeArray = flatten(dataArray);\n    const field = scale.field;\n    let min = scale.min;\n    let max = scale.max;\n    for (let index = 0; index < mergeArray.length; index++) {\n      const obj = mergeArray[index];\n      const tmpMin = Math.min.apply(null, obj[field]);\n      const tmpMax = Math.max.apply(null, obj[field]);\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n    const scaleDefs = this.scaleDefs;\n    const cfg: LooseObject = {};\n    if (min < scale.min && !get(scaleDefs, [field, 'min'])) {\n      // 用户如果在列定义中定义了 min，则以用户定义的为准\n      cfg.min = min;\n    }\n    if (max > scale.max && !get(scaleDefs, [field, 'max'])) {\n      // 用户如果在列定义中定义了 max\n      cfg.max = max;\n    }\n\n    scale.change(cfg);\n  }\n\n  // 将数据映射至图形空间前的操作：排序以及关键点的生成\n  private beforeMapping(beforeMappingData: Data[]) {\n    // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n    // const source = clone(beforeMappingData);\n    const source = beforeMappingData;\n    if (this.sortable) {\n      this.sort(source);\n    }\n    if (this.generatePoints) {\n      // 需要生成关键点\n      for (let index = 0, length = source.length; index < length; index++) {\n        const currentData = source[index];\n        this.generateShapePoints(currentData);\n        const nextData = source[index + 1];\n        if (nextData) {\n          this.generateShapePoints(nextData);\n          currentData[0].nextPoints = nextData[0].points;\n        }\n      }\n    }\n\n    return source;\n  }\n\n  // 生成 shape 的关键点\n  private generateShapePoints(data: Data) {\n    const shapeFactory = this.getShapeFactory();\n    const shapeAttr = this.getAttribute('shape');\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const cfg = this.createShapePointsCfg(obj);\n      const shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n      const points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  }\n\n  // 将数据归一化\n  private normalizeValues(values, scale) {\n    let rst = [];\n    if (isArray(values)) {\n      for (let index = 0; index < values.length; index++) {\n        const value = values[index];\n        rst.push(scale.scale(value));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n    return rst;\n  }\n\n  // 将数据映射至图形空间\n  private mapping(data: Data): MappingDatum[] {\n    const attributes = this.attributes;\n    const mappingData = [];\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const newRecord: MappingDatum = {\n        _origin: record[FIELD_ORIGIN],\n        points: record.points,\n        nextPoints: record.nextPoints,\n      };\n      for (const k in attributes) {\n        if (attributes.hasOwnProperty(k)) {\n          const attr = attributes[k];\n          const names = attr.names;\n          const values = this.getAttributeValues(attr, record);\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (let j = 0; j < values.length; j += 1) {\n              const val = values[j];\n              const name = names[j];\n              newRecord[name] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n\n      this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n      mappingData.push(newRecord);\n    }\n\n    return mappingData;\n  }\n\n  // 将归一化的坐标值转换成画布坐标\n  private convertPoint(mappingRecord: MappingDatum) {\n    const { x, y } = mappingRecord;\n\n    let rstX;\n    let rstY;\n    let obj;\n    const coordinate = this.coordinate;\n    if (isArray(x) && isArray(y)) {\n      rstX = [];\n      rstY = [];\n      for (let i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n        obj = coordinate.convert({\n          x: x[i],\n          y: y[j],\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      rstY = [];\n      for (let index = 0; index < y.length; index++) {\n        const yVal = y[index];\n        obj = coordinate.convert({\n          x: x as number,\n          y: yVal,\n        });\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n        rstY.push(obj.y);\n      }\n    } else if (isArray(x)) {\n      rstX = [];\n      for (let index = 0; index < x.length; index++) {\n        const xVal = x[index];\n        obj = coordinate.convert({\n          x: xVal,\n          y,\n        });\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n        rstX.push(obj.x);\n      }\n    } else {\n      const point = coordinate.convert({\n        x,\n        y,\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n    mappingRecord.x = rstX;\n    mappingRecord.y = rstY;\n  }\n\n  // 获取 style 配置\n  private getStyleCfg(styleOption: StyleOption, originData: Datum) {\n    const { fields = [], callback, cfg } = styleOption;\n    if (cfg) {\n      // 用户直接配置样式属性\n      return cfg;\n    }\n\n    const params = fields.map((field) => {\n      return originData[field];\n    });\n\n    return callback(...params);\n  }\n\n  private setCfg(cfg: InitCfg) {\n    const { coordinate, data, theme, scaleDefs } = cfg;\n    if (coordinate) {\n      this.coordinate = coordinate;\n    }\n    if (data) {\n      this.data = data;\n    }\n    if (scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.idFields = [];\n      each(scaleDefs, (scaleDef, field) => {\n        if (scaleDef && scaleDef.key) {\n          this.idFields.push(field);\n        }\n      });\n    }\n    if (theme) {\n      this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n    }\n  }\n\n  private async renderLabels(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    let geometryLabel = this.geometryLabel;\n\n    this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);\n\n    if (!geometryLabel) {\n      // 初次创建\n      const labelType = this.getLabelType();\n      const GeometryLabelsCtor = getGeometryLabel(labelType);\n      geometryLabel = new GeometryLabelsCtor(this);\n      this.geometryLabel = geometryLabel;\n    }\n    await geometryLabel.render(mappingArray, isUpdate);\n\n    // 将 label 同 element 进行关联\n    const labelsMap = geometryLabel.labelsRenderer.shapesMap;\n    // Store labels for every element.\n    const elementLabels = new Map<Element, Set<IGroup>>();\n    each(labelsMap, (labelGroup: IGroup, labelGroupId: string) => {\n      const labelChildren = labelGroup.getChildren() || [];\n      for (let j = 0; j < labelChildren.length; j++) {\n        const labelShape = labelChildren[j];\n        const element = this.elementsMap[labelShape.get('elementId') || labelGroupId.split(' ')[0]];\n        if (element) {\n          labelShape.cfg.name = ['element', 'label'];\n          labelShape.cfg.element = element;\n          const labels = elementLabels.get(element) || new Set();\n          labels.add(labelGroup);\n          elementLabels.set(element, labels);\n        }\n      }\n    });\n    for (const [element, labels] of elementLabels.entries()) {\n      element.labelShape = [...labels];\n    }\n\n    this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);\n  }\n  /**\n   * 是否需要进行群组入场动画\n   * 规则：\n   * 1. 如果发生更新，则不进行\n   * 2. 如果用户关闭 geometry 动画，则不进行\n   * 3. 如果用户关闭了 appear 动画，则不进行\n   * 4. 如果用户配置了 appear.animation，则不进行\n   */\n  private canDoGroupAnimation(isUpdate: boolean) {\n    return (\n      !isUpdate &&\n      this.animateOption &&\n      (get(this.animateOption, 'appear') === undefined ||\n        (get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined))\n    );\n  }\n}\n"],"names":["cfg","_super","_this","container","labelsContainer","coordinate","data","_a","sortable","_b","visible","theme","_c","scales","_d","scaleDefs","intervalPadding","dodgePadding","maxColumnWidth","minColumnWidth","columnWidthRatio","roseWidthRatio","multiplePieWidthRatio","zIndexReversed","sortZIndex","useDeferredLabel","userTheme","Infinity","__extends","Geometry","positionCfg","isPlainObject","fields","parseFields","get","length","unshift","set","this","attributeOption","field","createAttrOption","adjustCfg","adjusts","isString","each","adjust","index","isObject","type","adjustOption","styleFunc","styleOption","callback","tooltipOption","animateOption","secondParam","thirdParam","labelOption","isFunction","stateOption","customOption","setCfg","initAttributes","processData","adjustScale","isDataChanged","isCoordinateChanged","lastAttributeOption","isEqual","init","isUpdate","deepMix","getDefaultAnimateCfg","defaultSize","undefined","elementsMap","elements","getOffscreenGroup","clear","beforeMappingData","dataArray","beforeMapping","Array","i","mapping","updateElements","lastElementsMap","canDoGroupAnimation","animateCfg","yScale","getYScale","yMinPoint","convert","x","y","scale","getYMinValue","doGroupAppearAnimate","deferred","renderLabels","flatten","bind","timeout","window","requestIdleCallback","options","setTimeout","__assign","changeVisible","geometryLabel","offscreenGroup","attributes","idFields","groupScales","hasSorted","remove","destroy","shapeFactory","call","name","getAttribute","rst","attr","GROUP_ATTRS","push","attrName","value","isEmpty","values","obj","params","length_1","isIdentity","apply","__spreadArray","adjustType","shapeName","getShapeFactory","getMarker","condition","filter","element","originData","isArray","FIELD_ORIGIN","elementId","xVal","id","xScale","getXScale","xField","yVal","concat","length_2","dodgeAdjust","getAdjust","dodgeBy","tmpMap","Map","attributeType","hasOwnProperty","eachOpt","uniq","length_3","show","hide","uniqMap","Object","forEach","f","has","groupFields","length_4","attributeName","position","getXYFields","map","shape","GroupCtor","getGroupBase","mappingArray","xScale_1","xField_1","sort","obj1","obj2","translate","updateStackRange","shapeType","clone","geometries","normalizeValues","y0","mappingDatum","shapeCfg","getDrawCfg","Element","elementIndex","animate","geometry","draw","mappingData","color","size","isInCircle","isPolar","customInfo","defaultShapeType","defaultStyle","style","getDefaultStyle","getStyleCfg","generatePoints","points","nextPoints","mappingDataArray","keyDatum","keys","keyIndex","j","key","getElementId","finalKey","diff","added","updated","removed","added_1_1","createElement","updated_1_1","currentShapeCfg","preShapeCfg","getModel","isModelChange","update","removed_1_1","coordinateType","isTransposed","labelType","min","max","isNil","attrCfg","isNumber","attrType","option","inferScaleType","sizes","shapes","colors10","colors20","AttributeCtor","getAttributeClass","categoryScales","isCategory","groupedArray","groupData","beforeAdjust","len","subData","arr","subLen","item","k","categoryScales_1_1","adjustData","result","xScale_2","yField","xDimensionLength","getXDimensionLength","groupNum","sizeAttr","adjustNames","Error","dodgeRatio","height","getHeight","getDefaultValue","reverseOrder","adjustCtor","getAdjustClass","dimValuesMap","v","adjustInstance","process","getGroupScales","appendConditions","group","mergeArray","tmpMin","Math","tmpMax","change","source","length_5","currentData","generateShapePoints","nextData","shapeAttr","createShapePointsCfg","getAttributeValues","getShapePoints","record","newRecord","_origin","names","val","convertPoint","mappingRecord","rstX","rstY","xLen","yLen","point","scaleDef","emit","GEOMETRY_LIFE_CIRCLE","getLabelType","GeometryLabelsCtor","getGeometryLabel","render","_e","labelsMap","labelsRenderer","shapesMap","elementLabels","labelGroup","labelGroupId","labelChildren","getChildren","labelShape","split","labels","Set","add","entries","Base"],"sourceRoot":""}